---
layout: 2x2-grid-header 
title: {{article}}  
zoom: 0.6   
disabled: false 
hide: false 
hideInToc: false    
preload: true   
---


# {{article}}   


::top-left::

**Overview**

<Transform :scale="0.5">
    <img src="/images/argocd_architecture.webp"  />
</Transform>     
::top-right::

**Concepts**    
- Application A group of Kubernetes resources (CRD) as defined by a manifest. 
- Application source type Which Tool is used to build the application.
- Target state The desired state of an application, as represented by files in a Git repository.
- Live state The live state of that application. What pods etc are deployed.
- Sync status Whether or not the live state matches the target state. Is the deployed application the same as Git says it should be?
- Sync The process of making an application move to its target state. E.g. by applying changes to a Kubernetes cluster.
- Sync operation status Whether or not a sync succeeded.
- Refresh Compare the latest code in Git with the live state. Figure out what is different.
- Health The health of the application, is it running correctly? Can it serve requests?

::bottom-left::
**Commands**    

```bash
argocd admin initial-password -n argocd
argocd login <ARGOCD_SERVER>
argocd app sync
```

::bottom-right::
**Manifests**   
Argo CD supports several different ways in which Kubernetes manifests can be defined:
- Kustomize applications
- Helm charts
- A directory of YAML/JSON/Jsonnet manifests, including Jsonnet.
- Any custom config management tool configured as a config management plugin
